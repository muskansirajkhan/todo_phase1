# Hackathon II Todo App - Project Constitution

## Project Identity
**Project Name:** The Evolution of Todo – Mastering Spec-Driven Development & Cloud Native AI
**Mission:** To master the art of building applications iteratively—starting from a simple console app and evolving it into a fully-featured, cloud-native AI chatbot deployed on Kubernetes. This journey will teach the Nine Pillars of AI-Driven Development, Claude Code, Spec-Driven Development with Reusable Intelligence and Cloud-Native AI technologies through hands-on implementation.

## Core Principles

### 1. Spec-Driven Development First
- All features must be specified before implementation
- Specifications are living documents that evolve with the project
- Claude Code must reference specifications using @specs/ notation
- Implementation follows the specification, not the other way around

### 2. AI-First Development
- Use Claude Code as the primary implementation tool
- Specifications should be detailed enough for AI to understand and implement
- Human role is system architect, not syntax writer
- Leverage Reusable Intelligence (Agent Skills and Subagents)

### 3. Iterative Evolution
- Build incrementally from Phase I to Phase V
- Each phase builds upon the previous phase
- Maintain backward compatibility where possible
- Code refactoring is expected between phases

### 4. Quality Gates
- All code must pass through Claude Code for implementation
- No manual coding - only specification refinement until Claude Code generates correct output
- Each phase must be tested locally before progression
- GitHub commits must follow proper conventions

### 5. Cloud-Native Architecture
- Design with eventual cloud deployment in mind
- Use stateless components where possible
- Plan for scalability from the beginning
- Follow 12-factor app methodology

## Phase-Specific Principles

### Phase I: In-Memory Python Console App
- Focus on core CRUD functionality
- Use in-memory storage initially
- Implement all 5 Basic Level features (Add, Delete, Update, View, Mark Complete)
- Establish proper Python project structure with UV
- Use Claude Code and Spec-Kit Plus for all implementation

### Phase II: Full-Stack Web Application
- Add persistent storage with Neon Serverless PostgreSQL
- Implement user authentication with Better Auth
- Create responsive frontend with Next.js
- Build RESTful API with FastAPI and SQLModel

### Phase III: AI-Powered Todo Chatbot
- Integrate OpenAI Agents SDK for AI logic
- Build MCP server with Official MCP SDK
- Create conversational interface using natural language
- Implement stateless architecture with database persistence

### Phase IV: Local Kubernetes Deployment
- Containerize applications with Docker
- Deploy on Minikube with Helm Charts
- Use AIOps tools (kubectl-ai, kagent, Gordon)

### Phase V: Advanced Cloud Deployment
- Implement advanced features (recurring tasks, due dates)
- Add event-driven architecture with Kafka
- Deploy on DigitalOcean Kubernetes
- Implement Dapr for distributed application runtime

## Technology Stack Commitments

### Core Stack
- Claude Code + Spec-Kit Plus (for all development)
- Python 3.13+ with UV package manager
- Next.js 16+ (App Router) for frontend
- FastAPI for backend
- SQLModel for ORM
- Neon Serverless PostgreSQL for database
- Better Auth for authentication
- OpenAI Agents SDK for AI
- Official MCP SDK for Model Context Protocol
- Docker, Kubernetes, Minikube, Helm for deployment
- Kafka (Redpanda) for event streaming
- Dapr for distributed application runtime

### Quality Tools
- Git for version control
- GitHub for repository hosting
- Vercel for frontend deployment
- Proper testing at each phase

## Workflow Commitments

### Development Workflow
1. Constitution (/sp.constitution): Define/update project principles
2. Specify (/sp.specify): Create features specification with user stories
3. Clarify (/sp.clarify): Resolve ambiguities in specifications
4. Plan (/sp.plan): Generate technical implementation plan
5. Tasks (/sp.tasks): Break down into actionable, testable tasks
6. Implement (/sp.implement): Execute tasks using Red-Green-Refactor
7. Document (/sp.adr): Record architectural decisions when significant
8. Record (/sp.phr): Create prompt History Records for traceability

### Quality Gates
- Each phase must be fully functional before progression
- Local testing required before moving to next phase
- GitHub commits for each phase
- Demo videos for final submission
- Specifications must be comprehensive enough for AI implementation

## Success Metrics
- Completion of all 5 phases with functional implementations
- Proper adherence to Spec-Driven Development workflow
- Successful deployment on cloud infrastructure
- Clean, maintainable code generated through Claude Code
- Achievement of bonus points through Reusable Intelligence, Multi-language support, Voice Commands, and Cloud-Native Blueprints